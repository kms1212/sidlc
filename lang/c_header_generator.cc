#include <c_header_generator.hh>

#include <uuid.h>

#include <ast.hh>

#include "config.h"

void CHeaderGenerator::visit(InterfaceNode &node)
{
    macro_interface_name = node.name;
    std::transform(
        macro_interface_name.begin(),
        macro_interface_name.end(),
        macro_interface_name.begin(),
        ::toupper
    );

    for (const auto &anno : node.annotations) {
        if (anno->name == "prefix") {
            if (anno->args.size() != 1) {
                throw std::runtime_error("Invalid argument size");
            }

            auto prefix_param = dynamic_cast<StringLiteralExpressionNode *>(anno->args[0].get());
            if (!prefix_param) {
                throw std::runtime_error("Invalid argument type");
            }

            prefix = prefix_param->value.substr(1, prefix_param->value.size() - 2);
            macro_prefix = prefix;
            std::transform(
                macro_prefix.begin(),
                macro_prefix.end(),
                macro_prefix.begin(),
                ::toupper
            );
        } else if (anno->name == "uuid") {
            if (anno->args.size() != 2) {
                throw std::runtime_error("Invalid argument size");
            }

            auto namespace_param = dynamic_cast<StringLiteralExpressionNode *>(anno->args[0].get());
            if (!namespace_param) {
                throw std::runtime_error("Invalid argument type");
            }

            std::string_view namespace_str =
                namespace_param->value.substr(1, namespace_param->value.size() - 2);
            if (!uuids::uuid::is_valid_uuid(namespace_str)) {
                throw std::runtime_error("Invalid UUID");
            }

            auto uuid = uuids::uuid::from_string(namespace_str);
            if (!uuid) {
                throw std::runtime_error("Invalid UUID");
            }

            auto name_param = dynamic_cast<StringLiteralExpressionNode *>(anno->args[1].get());
            if (!name_param) {
                throw std::runtime_error("Invalid argument type");
            }

            std::string_view name_str = name_param->value.substr(1, name_param->value.size() - 2);

            uuids::uuid_name_generator gen(uuid.value());
            auto final_uuid = gen(name_str);

            std::span<const std::byte, 16> bytes = final_uuid.as_bytes();

            buf_macros << "#define UUID_" << macro_interface_name << "_INTERFACE ((struct StUuid){ "
                       << std::hex;
            for (size_t i = 0; i < bytes.size(); i++) {
                buf_macros << "0x" << static_cast<int>(bytes[i]) << ", ";
            }
            buf_macros << std::dec << "});\n";
        }
    }

    for (const auto &group : node.groups) {
        group->accept(*this);
    }

    out << "/* =====================================================================\n";
    out << " * Auto-generated by sidlc v" << SIDLC_VERSION << " (" << SIDLC_GIT_HASH << ")\n";
    out << " * Target Interface: " << node.name << "\n";
    out << " * DO NOT EDIT THIS FILE MANUALLY!\n";
    out << " * ===================================================================== */\n\n";

    out << "#ifndef __SIDL_INTERFACE_" << macro_interface_name << "_HH__\n";
    out << "#define __SIDL_INTERFACE_" << macro_interface_name << "_HH__\n\n";
    out << "#include <stdint.h>\n\n";
    out << "#include <strata/status.h>\n";
    out << "#include <strata/macros.h>\n";
    out << "#include <strata/uuid.h>\n\n";

    if (buf_macros.tellp() > 0) {
        out << "/* Constants & Bitmasks */\n";
        out << buf_macros.str() << "\n";
    }

    if (buf_types.tellp() > 0) {
        out << "/* Types & Structures */\n";
        out << buf_types.str() << "\n";
    }

    if (buf_functions.tellp() > 0) {
        out << "/* Functions & Views */\n";
        out << buf_functions.str() << "\n";
    }
    out << "#endif /* __SIDL_INTERFACE_" << macro_interface_name << "_HH__ */\n";
}

void CHeaderGenerator::visit(GroupNode &node)
{
    for (const auto &abi : node.abiversions) {
        abi->accept(*this);
    }
}

void CHeaderGenerator::visit(AbiversionNode &node)
{
    if (!node.bitfields.empty()) {
        buf_macros << "\n/* ABI Version " << node.version << " */\n";
    }

    if (!node.structs.empty() || !node.bitfields.empty()) {
        buf_types << "\n/* ABI Version " << node.version << " */\n";
    }

    if (!node.functions.empty()) {
        buf_functions << "\n/* ABI Version " << node.version << " */\n";
    }

    for (const auto &s : node.structs) {
        s->accept(*this);
    }

    for (const auto &b : node.bitfields) {
        b->accept(*this);
    }

    for (const auto &f : node.functions) {
        f->accept(*this);
    }
}

void CHeaderGenerator::visit(StructNode &node)
{
    std::string attributes = "";

    for (const auto &anno : node.annotations) {
        if (anno->name == "align_size" && !anno->args.empty()) {
            attributes += " __attribute__((aligned(16)))";
        }
    }

    buf_types << "struct " << prefix << node.name << " {\n";

    for (const auto &field : node.fields) {
        if (field->type->is_ptr) {
            buf_types << "    " << to_c_type(prefix, *field->type) << field->name << ";\n";
        } else {
            buf_types << "    " << to_c_type(prefix, *field->type) << " " << field->name << ";\n";
        }
    }

    buf_types << "}" << attributes << ";\n\n";
}

void CHeaderGenerator::visit(BitfieldNode &node)
{
    uint64_t offset = 0;
    std::string macro_name = std::string(node.name);
    std::transform(macro_name.begin(), macro_name.end(), macro_name.begin(), ::toupper);

    buf_types << "typedef " << to_c_type(prefix, *node.base_type) << " " << prefix << node.name
              << ";\n";

    for (const auto &field : node.fields) {
        buf_macros << "#define " << macro_name << "_" << field->name << " ("
                   << (1ULL << field->bits) - 1 << "ULL << " << offset << ")\n";
        offset += field->bits;
    }
}

void CHeaderGenerator::visit(FunctionNode &node)
{
    buf_functions << "StStatus " << prefix << node.name << "(StHandle handle __in, ";

    for (const auto &param : node.parameters) {
        bool add_pointer = param->direction != ParameterNode::Direction::IN;

        if (param->type->is_ptr) {
            buf_functions << to_c_type(prefix, *param->type) << (add_pointer ? "*" : "")
                          << param->name;
        } else {
            buf_functions << to_c_type(prefix, *param->type) << (add_pointer ? " *" : " ")
                          << param->name;
        }

        switch (param->direction) {
        case ParameterNode::Direction::IN:
            buf_functions << " __in";
            break;
        case ParameterNode::Direction::OUT:
            buf_functions << " __out";
            break;
        case ParameterNode::Direction::INOUT:
            buf_functions << " __inout";
            break;
        }

        if (&param != &node.parameters.back()) {
            buf_functions << ", ";
        }
    }

    buf_functions << ");\n";
}
