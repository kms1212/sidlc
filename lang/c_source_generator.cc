#include <c_source_generator.hh>

#include <uuid.h>

#include <ast.hh>

#include "config.h"

void CSourceGenerator::visit(InterfaceNode &node)
{
    macro_interface_name = node.name;
    std::transform(
        macro_interface_name.begin(),
        macro_interface_name.end(),
        macro_interface_name.begin(),
        ::toupper
    );

    for (const auto &anno : node.annotations) {
        if (anno->name == "prefix") {
            if (anno->args.size() != 1) {
                throw std::runtime_error("Invalid argument size");
            }

            auto prefix_param = dynamic_cast<StringLiteralExpressionNode *>(anno->args[0].get());
            if (!prefix_param) {
                throw std::runtime_error("Invalid argument type");
            }

            prefix = prefix_param->value.substr(1, prefix_param->value.size() - 2);
        }
    }

    for (const auto &group : node.groups) {
        group->accept(*this);
    }

    out << "/* =====================================================================\n";
    out << " * Auto-generated by sidlc v" << SIDLC_VERSION << " (" << SIDLC_GIT_HASH << ")\n";
    out << " * Target Interface: " << node.name << "\n";
    out << " * DO NOT EDIT THIS FILE MANUALLY!\n";
    out << " * ===================================================================== */\n\n";

    out << "#include \"" << header_name << "\"\n\n";
    out << "#include <stdint.h>\n\n";
    out << "#include <strata/status.h>\n";
    out << "#include <strata/macros.h>\n";
    out << "#include <strata/uuid.h>\n";
    out << "#include <strata/krt.h>\n\n";

    if (buf_macros.tellp() > 0) {
        out << "/* Constants & Bitmasks */\n";
        out << buf_macros.str() << "\n";
    }

    out << "extern StStatus __get_func_id_base(StHandle handle __in, const struct StUuid *uuid "
           "__in, "
           "uint32_t request_groupid __in, uint32_t request_abiver __in, uint32_t *funcid_base "
           "__out, uint32_t *result_abiver __out);\n\n";
    out << "static const struct StUuid interface_uuid = UUID_" << macro_interface_name
        << "_INTERFACE_INIT;\n\n";

    if (buf_functions.tellp() > 0) {
        out << "/* Functions & Views */\n";
        out << buf_functions.str() << "\n";
    }
}

void CSourceGenerator::visit(GroupNode &node)
{
    buf_macros << "\n/* Group " << node.name << " */\n";
    buf_functions << "\n/* Group " << node.name << " */\n";
    for (const auto &abi : node.abiversions) {
        abi->accept(*this);
    }
}

void CSourceGenerator::visit(AbiversionNode &node)
{
    if (!node.functions.empty()) {
        buf_macros << "\n/* ABI Version " << node.version << " */\n";
        buf_functions << "\n/* ABI Version " << node.version << " */\n";
    }

    for (const auto &f : node.functions) {
        f->accept(*this);
    }
}

void CSourceGenerator::visit(FunctionNode &node)
{
    buf_macros << "#define FUNCID_" << node.name << " " << current_funcid++ << "\n";

    if (node.parameters.empty()) {
        buf_functions << "StStatus " << prefix << node.name << "(StHandle handle __in";
    } else {
        buf_functions << "StStatus " << prefix << node.name << "(StHandle handle __in, ";
    }

    for (const auto &param : node.parameters) {
        bool add_pointer = param->direction != ParameterNode::Direction::IN;

        if (param->type->is_ptr) {
            buf_functions << to_c_type(prefix, *param->type) << (add_pointer ? "*_" : "_")
                          << param->name;
        } else {
            buf_functions << to_c_type(prefix, *param->type) << (add_pointer ? " *_" : " _")
                          << param->name;
        }

        switch (param->direction) {
        case ParameterNode::Direction::IN:
            buf_functions << " __in";
            break;
        case ParameterNode::Direction::OUT:
            buf_functions << " __out";
            break;
        case ParameterNode::Direction::INOUT:
            buf_functions << " __inout";
            break;
        }

        if (&param != &node.parameters.back()) {
            buf_functions << ", ";
        }
    }

    buf_functions << ")\n";

    bool has_out_params = false;
    bool has_nonout_params = false;
    for (const auto &param : node.parameters) {
        if (param->direction == ParameterNode::Direction::OUT) {
            has_out_params = true;
        } else {
            has_nonout_params = true;
        }

        if (has_out_params && has_nonout_params) {
            break;
        }
    }

    buf_functions << "{\n";
    buf_functions << "    uint32_t funcid;\n";
    buf_functions << "    StStatus status;\n";

    if (has_nonout_params) {
        buf_functions << "    struct {\n";
        for (const auto &param : node.parameters) {
            if (param->direction == ParameterNode::Direction::OUT) {
                continue;
            }
            if (param->type->is_ptr) {
                buf_functions << "        " << to_c_type(prefix, *param->type) << param->name
                              << ";\n";
            } else {
                buf_functions << "        " << to_c_type(prefix, *param->type) << " " << param->name
                              << ";\n";
            }
        }
        buf_functions << "    } __packed in = {\n";
        for (const auto &param : node.parameters) {
            if (param->direction == ParameterNode::Direction::OUT) {
                continue;
            }
            if (param->type->is_ptr) {
                buf_functions << "        ." << param->name << " = _" << param->name << ",\n";
            } else {
                buf_functions << "        ." << param->name << " = _" << param->name << ",\n";
            }
        }
        buf_functions << "    };\n";
    }
    if (has_out_params) {
        buf_functions << "    struct {\n";
        for (const auto &param : node.parameters) {
            if (param->direction != ParameterNode::Direction::OUT) {
                continue;
            }
            if (param->type->is_ptr) {
                buf_functions << "        " << to_c_type(prefix, *param->type) << param->name
                              << ";\n";
            } else {
                buf_functions << "        " << to_c_type(prefix, *param->type) << " " << param->name
                              << ";\n";
            }
        }
        buf_functions << "    } __packed out;\n";
    }
    buf_functions << "    status = __get_func_id_base(handle, &interface_uuid, 0, 0, "
                     "&funcid, NULL);\n";
    buf_functions << "    if (!CHECK_SUCCESS(status)) { return status; }\n";
    buf_functions << "    status = StKrt_Call(handle, FUNCID_" << node.name << ", ";
    if (has_nonout_params) {
        buf_functions << "&in, sizeof(in), ";
    } else {
        buf_functions << "NULL, 0, ";
    }
    if (has_out_params) {
        buf_functions << "&out, sizeof(out)";
    } else {
        buf_functions << "NULL, 0";
    }
    buf_functions << ");\n";
    buf_functions << "    if (!CHECK_SUCCESS(status)) { return status; }\n";

    if (has_out_params) {
        for (const auto &param : node.parameters) {
            if (param->direction != ParameterNode::Direction::OUT) {
                continue;
            }
            buf_functions << "    if (_" << param->name << " != NULL) { *_" << param->name
                          << " = out." << param->name << "; }\n";
        }
    }

    buf_functions << "    return STATUS_SUCCESS;\n";
    buf_functions << "}\n\n";
}
